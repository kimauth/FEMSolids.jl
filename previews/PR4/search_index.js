var documenterSearchIndex = {"docs":
[{"location":"old/#Old-code-from-previous-course-revisions","page":"Old","title":"Old code from previous course revisions","text":"","category":"section"},{"location":"old/","page":"Old","title":"Old","text":"Equivalent functionality is now documented provided in Ferrite v1. Included here for legacy reasons.","category":"page"},{"location":"old/#FEMSolids.LinearElasticity","page":"Old","title":"FEMSolids.LinearElasticity","text":"LinearElasticity{dim}(;G, K) where dim\n\nConstruct a LinearElasticity material based on the shear modulus G and the bulk modulus K.\n\n\n\n\n\n","category":"type"},{"location":"old/#FEMSolids.Neumann","page":"Old","title":"FEMSolids.Neumann","text":"Neumann(f::Function, facetset::AbstractSet{FacetIndex}, nfacets::Int)\n\nRepresent a Neumann boundary condition.\n\nArguments:\n\nf: Prescribed traction as a function f(x,t), with spatial coordinate x and time t\nfacetset: The facets on which the boundary condition acts\nnfacets: Number of facets per cell\n\nExample:\n\ngrid = generate_grid(Quadrilateral, (5,5))\n\nprescribed_traction(x,t) = Vec(zero(t), x[1]*t)\nfacetset = getfacetset(grid, \"top\")\nnfacets = nfacets(getcells(grid, 1))\n\nneumann_bc = Neumann(prescribed_traction, facetset, nfacets)\n\nnote: Note\nNeumann needs to be updated once for each time step with update! and once for each cell with update_cell!. \n\n\n\n\n\n","category":"type"},{"location":"old/#FEMSolids.Primal","page":"Old","title":"FEMSolids.Primal","text":"Primal(material, thickness::Float64)\n\nRepresent the weak form of the moment equilibrium in primal format:\n\nint_Omega boldsymbolsigma  boldsymbolvarepsilon(delta boldsymbolu)  mathrmdOmega =\nint_Omega boldsymbolb cdot deltaboldsymbolu  mathrmdOmega + int_partialOmega_mathrmN boldsymbolt_mathrmp cdot deltaboldsymbolu  mathrmdGamma\n\nwhere boldsymbolsigma is the stress tensor, $ \\boldsymbol{\\varepsilon} $ is  the strain tensor, $ \\boldsymbol{b} $ is the vector of body forces, $ \\boldsymbol{t}_\\mathrm{p} $ is the prescribed boundary traction and $ \\delta \\boldsymbol{u} $ is the test function.\n\nBoundary conditions on the Dirichlet boundary Gamma_textD and the Neumann boundary Gamma_textN are respectively given as:\n\nbeginaligned\nboldsymbolu = boldsymbolu_textp quad texton quad Gamma_textD \nboldsymbolsigma cdot boldsymboln = boldsymbolt_textp quad texton quad Gamma_textN \nendaligned\n\nwhere boldsymbolu is the displacement field.\n\nArguments:\n\nmateral: Material model for the stress-strain relation\nthickness: Cross-sectional area / out-of-plane thickness for 1D / 2D problems \n\n\n\n\n\n","category":"type"},{"location":"old/#FEMSolids.element_routine!","page":"Old","title":"FEMSolids.element_routine!","text":"element_routine!(weak_form::Primal, ke, fe, fe_external, cv, xe, ue [, fv, neumann_bc::Neumann])\n\nCompute the element stiffness matrix ke, the internal force vector fe and the external  force vector fe_external:\n\nbeginaligned\n\nleft( textttke right)_ij = aleft( boldsymbolN^(rm u)_i  boldsymbolN^(rm u)_j right)\n= int_Omega boldsymbolnabla^textsym boldsymbolN^(rm u)_i  boldsymbolmathsfE \nboldsymbolnabla^textsym boldsymbolN^(rm u)_j rm d Omega \n\nleft( textttfe right)_i = aleft( boldsymbolu  boldsymbolN^(rm u)_j right)\n= int_Omega boldsymbolnabla^textsym boldsymbolu  boldsymbolmathsfE \nboldsymbolnabla^textsym boldsymbolN^(rm u)_j rm d Omega \n\nleft( textttfe_external right)_i = lleft( boldsymbolN^(rm u)_i right)\n= int_Gamma^(rm u)_textN  boldsymbolN^(rm u)_i cdot boldsymbolt_textp  rm d Gamma\n\nendaligned\n\nwhere boldsymbolN^(rm u)_i is the shape function for the i-th degree of freedom, $ \\mathsf{E} $ is the 4-th order elastic stiffness tensor, boldsymbolu is the  displacement and boldsymbolt_mathrmp is the prescribed traction.\n\nArguments:\n\nweak_form: weak form representation\nke: element stiffness matrix\nfe: element force vector\ncv: CellValues\nxe: element coordinate vector\nue: element displacement vector\n\nOptional arguments for integrating the load vector:\n\nfv: FaceVectorValues\nneumann_bc: Neumann boundary condition\n\n\n\n\n\n","category":"function"},{"location":"old/#FEMSolids.update_cell!","page":"Old","title":"FEMSolids.update_cell!","text":"update_cell!(bc::Neumann, cellid::Int)\n\nUpdate the Neumann boundary condition bc with the current cellid.\n\n\n\n\n\n","category":"function"},{"location":"old/#Ferrite.update!-Tuple{Neumann, Float64}","page":"Old","title":"Ferrite.update!","text":"update!(bc::Neumann, time::Float64=0.0)\n\nUpdate the Neumann boundary condition bc for the current time.\n\n\n\n\n\n","category":"method"},{"location":"adaptivity/#Mesh-adaptivity","page":"Adaptivity","title":"Mesh adaptivity","text":"","category":"section"},{"location":"adaptivity/#FEMSolids.refine","page":"Adaptivity","title":"FEMSolids.refine","text":"refine(grid::Grid, cells_to_split)\n\nRefine the given grid by applying the Rivara algorithm where cells_to_split is the list of cells to define (should contain cell numbers). This implementation is restricted to linear 2D Triangles.\n\nwarning: Warning\nnodesets, facesets and cellsets are currently lost after refinement and must be reconstructed. They can be added to a grid in the following manner:addfaceset!(mesh, \"left\", x -> x[1] ≈ 0.0)\naddfaceset!(mesh, \"bottom\", x -> x[2] ≈ 0.0)\naddfaceset!(mesh, \"Γₗ\", x -> (x[1] <= h && x[2] ≈ h))\n\n\n\n\n\n","category":"function"},{"location":"adaptivity/#FEMSolids.transfer_solution","page":"Adaptivity","title":"FEMSolids.transfer_solution","text":"transfer_solution(dh_from::DofHandler, dh_to::DofHandler, a_from::AbstractVector)\n\nInterpolate the solution a_from (associated with dh_from) to the degrees of freedom of the DofHandler dh_to. Return the interpolated values as a vector ordered according to the dofs in dh_to.\n\n\n\n\n\n","category":"function"},{"location":"#FEMSolids","page":"Home","title":"FEMSolids","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FEMSolids.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides routines that are needed for solving the assignments in FEM Solids,  in particular for mesh adaptivity","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url = \"https://github.com/kimauth/FEMSolids.jl\")","category":"page"}]
}
